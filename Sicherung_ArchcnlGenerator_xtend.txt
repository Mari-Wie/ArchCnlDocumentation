/*
 * generated by Xtext 2.14.0
 */
package org.architecture.cnl.generator

import api.APIFactory
import api.OntologyAPI
import datatypes.ArchitectureRules
import datatypes.RuleType
import java.io.File
import java.nio.file.Files
import java.util.ArrayList
import org.architecture.cnl.archcnl.CanOnlyRuleType
import org.architecture.cnl.archcnl.CardinalityRuleType
import org.architecture.cnl.archcnl.ConceptExpression
import org.architecture.cnl.archcnl.ConditionalRuleType
import org.architecture.cnl.archcnl.DataStatement
import org.architecture.cnl.archcnl.DatatypeRelation
import org.architecture.cnl.archcnl.MustRuleType
import org.architecture.cnl.archcnl.NegationRuleType
import org.architecture.cnl.archcnl.Nothing
import org.architecture.cnl.archcnl.ObjectConceptExpression
import org.architecture.cnl.archcnl.ObjectRelation
import org.architecture.cnl.archcnl.OnlyCanRuleType
import org.architecture.cnl.archcnl.Sentence
import org.architecture.cnl.archcnl.SubConceptRuleType
import org.architecture.cnl.archcnl.ThatExpression
import org.architecture.cnl.archcnl.VariableStatement
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.semanticweb.owlapi.model.OWLClass
import org.semanticweb.owlapi.model.OWLClassExpression
import org.semanticweb.owlapi.model.OWLDataProperty
import org.semanticweb.owlapi.model.OWLObjectProperty

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ArchcnlGenerator extends AbstractGenerator {

	String namespace
	OntologyAPI api 
	static int id = 0

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		namespace = "http://www.arch-ont.org/ontologies/architecture.owl"

		api = APIFactory.get();  
		api.createOntology("./architecture"+id+".owl", namespace)

		resource.allContents.toIterable.filter(typeof(Sentence)).forEach[s|s.compile]
		
		api.removeOntology(namespace);
		val f = new File("architecture"+id+".owl")
		Files.deleteIfExists(f.toPath)
	}

	def void compile(Sentence s) {
		val subject = s.subject
		val ruletype = s.ruletype
		val rules = ArchitectureRules.getInstance();
		
		//println("ID: " + id + " " + rules.getRuleWithID(id).cnlSentence)
		
		if (ruletype instanceof MustRuleType) {
			ruletype.compile(subject)
			rules.getRuleWithID(id).type = RuleType.EXISTENTIAL
		} else if (ruletype instanceof CanOnlyRuleType) {
			ruletype.compile(subject)
			rules.getRuleWithID(id).type = RuleType.UNIVERSAL
		} else if (ruletype instanceof OnlyCanRuleType) {
			ruletype.compile
			rules.getRuleWithID(id).type = RuleType.DOMAIN_RANGE
		} else if (ruletype instanceof ConditionalRuleType) {
			ruletype.compile
			rules.getRuleWithID(id).type = RuleType.CONDITIONAL
		} else if (ruletype instanceof NegationRuleType) {
			ruletype.compile
			rules.getRuleWithID(id).type = RuleType.NEGATION
		} else if (ruletype instanceof SubConceptRuleType) {
			ruletype.compile(subject)
			rules.getRuleWithID(id).type = RuleType.SUB_CONCEPT
		} else if (ruletype instanceof CardinalityRuleType) {
			ruletype.compile(subject)
		}
		
		id++
	}

	def void compile(SubConceptRuleType subconcept, ConceptExpression subject) {
		val subjectConceptExpression = subject.compile
		val object = api.getOWLClass(namespace, subconcept.object.concept.conceptName)

		api.addSubClassAxiom(namespace, object, subjectConceptExpression)
	}

	def void compile(CardinalityRuleType cardrule, ConceptExpression subject) {
		val subjectConceptExpression = subject.compile
		var object = cardrule.object.expression.compile
		val listResult = new ArrayList
		listResult.add(object)
		for (o : cardrule.object.objectAndList) {
			val result = o.expression.compile
			listResult.add(result)
		}
		if (listResult.size > 1) {
			object = api.intersectionOf(namespace, listResult)
			listResult.clear
		}

		for (o : cardrule.object.objectOrList) {
			val result = o.expression.compile
			listResult.add(result)
		}
		if (listResult.size > 1) {
			object = api.unionOf(namespace, listResult)
			listResult.clear
		}
		
		api.addSubClassAxiom(namespace,object,subjectConceptExpression) 
		
	}

	def void compile(NegationRuleType negation) {
		if (negation instanceof Nothing) {
			val subject = api.getOWLTop(namespace)
			var object = negation.object.expression.compile
			val listResult = new ArrayList
			listResult.add(object)
			for (o : negation.object.objectAndList) {
				val result = o.expression.compile
				listResult.add(result)
			}
			if (listResult.size > 1) {
				object = api.intersectionOf(namespace, listResult)
				listResult.clear
			}

			for (o : negation.object.objectOrList) {
				val result = o.expression.compile
				listResult.add(result)
			}
			if (listResult.size > 1) {
				object = api.unionOf(namespace, listResult)
				listResult.clear
			}

			api.addNegationAxiom(namespace, subject, object)
		} else {
			val subjectConceptExpression = negation.subject.compile
			if (negation.object.anything !== null) {
				val relation = api.getOWLObjectProperty(namespace,
					negation.object.anything.relation.relationName) as OWLObjectProperty
				var object = api.getOWLTop(namespace)
				api.addNegationAxiom(namespace, subjectConceptExpression, object, relation)
			} else {
				var object = negation.object.expression.compile
				val listResult = new ArrayList
				listResult.add(object)
				for (o : negation.object.objectAndList) {
					val result = o.expression.compile
					listResult.add(result)
				}
				if (listResult.size > 1) {
					object = api.intersectionOf(namespace, listResult)
					listResult.clear
				}

				for (o : negation.object.objectOrList) {
					val result = o.expression.compile
					listResult.add(result)
				}
				if (listResult.size > 1) {
					object = api.unionOf(namespace, listResult)
					listResult.clear
				}

				api.addNegationAxiom(namespace, subjectConceptExpression, object)

			}
		}
	}

	def void compile(ConditionalRuleType conditional) {
		conditional.subject.compile
		conditional.object.compile

		api.addSubPropertyOfAxiom(namespace, conditional.relation.relationName, conditional.relation2.relationName)
	}

	def void compile(OnlyCanRuleType onlycan) {
		val subjectConceptExpression = onlycan.subject.compile
		var object = onlycan.object.expression.concept.compile
		var relation = api.getOWLObjectProperty(namespace,
			onlycan.object.expression.relation.relationName) as OWLObjectProperty

		val objectOrList = onlycan.object.objectOrList
		val listResult = new ArrayList

		listResult.add(object)

		for (o : objectOrList) {
			val result = o.expression.concept.compile
			listResult.add(result)
		}

		object = api.unionOf(namespace, listResult)
		api.addDomainRangeAxiom(namespace, subjectConceptExpression, object, relation)

	}

	def void compile(CanOnlyRuleType canonly, ConceptExpression subject) {
		val subjectConceptExpression = subject.compile
		var object = canonly.object.expression.concept.compile
		var relation = api.getOWLObjectProperty(namespace,
			canonly.object.expression.relation.relationName) as OWLObjectProperty

		val objectAndList = canonly.object.objectAndList
		val objectOrList = canonly.object.objectOrList
		val listResult = new ArrayList

		object = api.createOnlyRestriction(namespace, relation, object)

		listResult.add(object)

		for (o : objectAndList) {
			var result = o.expression.concept.compile
			result = api.createOnlyRestriction(namespace,relation,result)
			listResult.add(result)
		}
		if (listResult.size > 1) {
			object = api.intersectionOf(namespace, listResult)
			listResult.clear
		}

		for (o : objectOrList) {
			var result = o.expression.concept.compile
			result = api.createOnlyRestriction(namespace,relation,result)
			listResult.add(result)
		}
		if (listResult.size > 1) {
			object = api.unionOf(namespace, listResult)
			listResult.clear
		}

		api.addSubClassAxiom(namespace, object, subjectConceptExpression)
	}

	def void compile(MustRuleType must, ConceptExpression subject) {
		// Process subject
		val subjectConceptExpression = subject.compile
		var object = must.object.expression.concept.compile
		var relation = api.getOWLObjectProperty(namespace,
			must.object.expression.relation.relationName) as OWLObjectProperty

		val objectAndList = must.object.objectAndList
		val objectOrList = must.object.objectOrList
		val listResult = new ArrayList
		object = api.addSomeValuesFrom(namespace, relation, object)
		listResult.add(object)
		for (o : objectAndList) {
			var result = o.expression.concept.compile
			result = api.addSomeValuesFrom(namespace,relation,result)
			listResult.add(result)
		}
		if (listResult.size > 1) {
			object = api.intersectionOf(namespace, listResult)
			listResult.clear
		}

		for (o : objectOrList) {
			var result = o.expression.concept.compile
			result = api.addSomeValuesFrom(namespace,relation,result)
			listResult.add(result)
		}
		if (listResult.size > 1) {
			object = api.unionOf(namespace, listResult)
			listResult.clear
		}

		api.addSubClassAxiom(namespace, object, subjectConceptExpression)

	}

	def OWLClassExpression compile(ObjectConceptExpression object) {
		val relation = api.getOWLObjectProperty(namespace, object.relation.relationName) as OWLObjectProperty
		val concept = object.concept.compile
		val count = object.number
		
		if(object.cardinality == 'at-most') {
			ArchitectureRules.getInstance().getRuleWithID(id).type = RuleType.AT_MOST
			return api.addMaxCardinalityRestrictionAxiom(namespace,concept,relation,count)
		}
		else if(object.cardinality == 'at-least') {
			ArchitectureRules.getInstance().getRuleWithID(id).type = RuleType.AT_LEAST
			return api.addMinCardinalityRestrictionAxiom(namespace, concept,relation,count)
		}
		else if(object.cardinality == 'exactly') {
			ArchitectureRules.getInstance().getRuleWithID(id).type = RuleType.EXACTLY
			return api.addExactCardinalityRestrictionAxiom(namespace, concept,relation,count)
		}
		else {
			return api.addSomeValuesFrom(namespace, relation, concept)			
		}
	}

	def OWLClassExpression compile(ConceptExpression conceptExpression) {

		val conceptAsOWL = api.getOWLClass(namespace, conceptExpression.concept.conceptName)

		var result = conceptAsOWL as OWLClassExpression
		val thatList = conceptExpression.that

		if (thatList.isEmpty) {
			return result
		} else {
			val that = thatList.get(0)

			result = that.compile
			result = api.intersectionOf(namespace, conceptAsOWL, result)

			return result
		}

	}

	def OWLClassExpression compile(ThatExpression that) {

		var results = new ArrayList<OWLClassExpression>

		for (statements : that.list) {
			val expression = statements.expression
			if (expression instanceof ConceptExpression) {
				val relation = statements.relation as ObjectRelation
				val thatRoleOWL = api.getOWLObjectProperty(namespace, relation.relationName) as OWLObjectProperty
				val owlexpression = expression.compile
				var result = api.addSomeValuesFrom(namespace, thatRoleOWL, owlexpression)
				results.add(result)
			// result = api.intersectionOf(namespace, conceptAsOWL, result)
			} else if (expression instanceof DataStatement) {
				println(statements.relation)
				val relation = statements.relation as DatatypeRelation
				val thatRoleOWL = api.getOWLDatatypeProperty(namespace, relation.relationName) as OWLDataProperty
				val dataString = expression.stringValue
				if (dataString !== null) {
					val dataHasValue = api.addDataHasValue(namespace, dataString, thatRoleOWL)
//					return dataHasValue
					results.add(dataHasValue)
//				result = api.intersectionOf(namespace, conceptAsOWL, dataHasValue)
				} else {
					val dataHasValue = api.addDataHasIntegerValue(namespace, expression.intValue, thatRoleOWL)
					results.add(dataHasValue)
//					return dataHasValue
//				result = api.intersectionOf(namespace, conceptAsOWL, dataHasValue)
				}
			} else if (expression instanceof VariableStatement) {
				println("with Variable")
				return null
			// TODO generate rules based on facts
			}

		}

		return api.intersectionOf(namespace, results)

	}

	def OWLClassExpression intersectionOf(OntologyAPI api, String string, OWLClassExpression expression1,
		OWLClassExpression expression2) {
		return api.intersectionOf(namespace, expression1, expression2)
	}

	def OWLClass getOWLClass(OntologyAPI api, String string, String string2) {
		return api.getOWLClass(string, string2)
	}
	
	
}
